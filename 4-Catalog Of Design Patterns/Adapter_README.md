## آداپتور (Adapter)
### به عنوان wrapper هم گفته میشود 



## 😟 مشکل 

تصور کنید در حال ساخت یک برنامه تحت نظارت بر یک بازار سهام هستید این برنامه داده های سهام را از چندین منابع مختلف در یافت میکند و در قالب 
`XML` دانلود میکند سپس نمودار ها را برای کاربر نشان میدهد 

حالا تصمیم میگیرید که که با ادغام بک کتابخانه خارجی اپلیکیشن را بهبود ببخشید ولی مشکل اینجاست که این کتابخانه فقط و تنها با فایل های  `Json` کار میکند و  دیتای شما بر خلاف چیزی است که در اختیار دارید 

![](https://github.com/ftg-iran/didp-persian/blob/main/4-Catalog%20Of%20Design%20Patterns/images/diagrams/adapter/problem-en.png)
=
شما نمی توانید از کتابخانه تجزیه و تحلیل «همانطور که هست» استفاده کنید، زیرا انتظار دارد داده ها در قالبی ناسازگار با برنامه شما باشد

شما میتوانید کتابخانه ی حاضر را برای کار با فرمت XML تغییر دهید اما ممکن است که کدهای برنامه که به این کتابخانه وابسته هستند دچار خطا شوند و از همه بدتر در وهله اول به سورس کد های آن کتابخانه دسترسی نداشته باشید که این رویکرد و تصمیم را غیر ممکن میکند.


## 😃 راه حل 

شما میتوانید یک اداپتور ایجاد کنید آداپتور آبجکتی باشد که میتواند اینترفیس یک آبجکت را به آبجکت دیگر تغییر دهد 


یعنی یک اداپتور یکی از آبجکت ها را مخفی میکند و پیچیدگی کار را نشان نمیدهد برای مثال شما میتوانید 
یک آبجکتی را که متر و کیلومتر را اندازه میگیرد به واسطه یک آداپتور به مایل و فوت تبدیل کنید


آداپتورها نه تنها می‌توانند داده‌ها را به فرمت‌های مختلف تبدیل کنند، بلکه می‌توانند به اشیاء با رابط‌های مختلف کمک کنند در اینجا نحوه عملکرد آن آمده است

- اداپتور یک رابطه سازگار با آبجکت پیدا میکند 
- با استفاده از این رابطه، آبجکت موجود میتواند راحت متود های داخل اداپتور را فراخوانی کند 
- پس از دریافت فراخوانی  آداپتور درخواست را به آبجکت دوم ارسال می کند، اما در قالب و ترتیبی که آبجکت دوم انتظار دارد.


 ***بعضی اوفات میتوان که اداپتوری ساخت دو طرفه باشد***


![Image](https://github.com/ftg-iran/didp-persian/blob/main/4-Catalog%20Of%20Design%20Patterns/images/diagrams/adapter/solution-en.png)

---

## 🚗در دنیای وافعی


هنگامی که برای اولین بار از ایالات متحده به اروپا سفر می کنید، ممکن است هنگام تلاش برای شارژ لپ تاپ خود غافلگیر شوید. استانداردهای دوشاخه و پریز برق در کشورهای مختلف متفاوت است.

![Image](https://github.com/ftg-iran/didp-persian/blob/main/4-Catalog%20Of%20Design%20Patterns/images/content/adapter/adapter-comic-1-en.png)

A suitcase before and after a trip abroad.

به همین دلیل است که دوشاخه ایالات متحده شما با سوکت آلمانی مناسب نیست. مشکل را می توان با استفاده از یک آداپتور برقی که دارای سوکت آمریکایی و دوشاخه سبک اروپایی است حل کرد.
یا به صورت کلی منظور یک تبدیل دو شاخه امریکایی به پریز برق های المانی است 

## 🚧 ساختار

#### شی مبدل 

این پیاده سازی از اصل ترکیب شی استفاده می کند: آداپتور رابط یک شی را پیاده سازی می کند و شی دیگر را  wrap میکند . می توان آن را در تمام زبان های برنامه نویسی رایج پیاده سازی کرد.


![](https://github.com/ftg-iran/didp-persian/blob/main/4-Catalog%20Of%20Design%20Patterns/images/diagrams/adapter/structure-object-adapter-indexed.png)


- کلاینت
کلاسی است که شامل منطق کسب و کار (business logic) موجود برنامه است 

- اینترفیس کلاینت پروتکلی را توصیف می کند که سایر کلاس ها باید از آن پیروی کنند تا بتوانند با کد مشتری همکاری کنن

- کلاس Service یک کلاسی است که شما میخواهید از آن استفاده کنید (معمولا یک پکیج خارجی یا کد قدیمی است). کلاینت نمیتواند مستقیما ازین سرویس استفاده کنتد چون اینترفیس های آن ا این سرویس ناسازگار می باشد.

- کلاس Adapter 
کلاسی است که می تواند هم با سرویس  و هم با کلاینت کار کند: این کلاس اینترفیس کلاینت  را پیاده سازی می کند، در حالی که آبجکت سرویس را هم wrap می کند. آداپتور فراخوانی ها  را از طریق اینترفیس آداپتور از کلاینت دریافت می‌کند و آنها را به فراخوانی هایی  با آبجکت wrap شده سرویس در قالبی که قابل درک باشد تبدیل  می‌کند.

- کد کلاینت  تا زمانی که از طریق اینترفیس کلاینت  با آداپتر کار می کند با کلاس غیرانتزاعی آداپتور همراه نمی شود. به لطف این موضوع، می توانید انواع جدیدی از آداپتورها را بدون شکستن کد کلاینت موجود وارد برنامه کنید. این می تواند زمانی مفید باشد که اینترفیس کلاس Service تغییر کند یا جایگزین شود: شما فقط می توانید یک کلاس آداپتور جدید بدون تغییر کد کلاینت  ایجاد کنید.



## کلاس آداپتور 

این پیاده سازی از وراثت  یا همان شی گرایی استفاده می کند: آداپتور اینترفیس ها را از هر دو آبجکت به طور همزمان به ارث می برد. توجه داشته باشید که این رویکرد فقط در زبان‌های برنامه‌نویسی که از وراثت چندگانه پشتیبانی می‌کنند، مانند C++ قابل پیاده‌سازی است.


![](https://github.com/ftg-iran/didp-persian/blob/main/4-Catalog%20Of%20Design%20Patterns/images/diagrams/adapter/structure-class-adapter-indexed.png)



#️⃣ شبه کد 

این نمونه از الگوی آداپتور مبتنی بر تداخل بین میخ های مربعی و سوراخ های گرد است.


![](https://github.com/ftg-iran/didp-persian/blob/main/4-Catalog%20Of%20Design%20Patterns/images/diagrams/adapter/example.png)


آداپتور وانمود می کند که یک میخ گرد است، با شعاع برابر با نیمی از قطر مربع (به عبارت دیگر، شعاع کوچکترین دایره ای که می تواند میخ مربع را در خود جای دهد).

```c++
// Say you have two classes with compatible interfaces:
// RoundHole and RoundPeg.
class RoundHole is
    constructor RoundHole(radius) { ... }
    method getRadius() is
        // Return the radius of the hole.
    method fits(peg: RoundPeg) is  
        return this.getRadius() >= peg.getRadius()
class RoundPeg is
    constructor RoundPeg(radius) { ... }
    method getRadius() is
        // Return the radius of the peg.
// But there's an incompatible class: SquarePeg.
class SquarePeg is
    constructor SquarePeg(width) { ... }
    method getWidth() is
        // Return the square peg width.
// An adapter class lets you fit square pegs into round holes.
// It extends the RoundPeg class to let the adapter objects act
// as round pegs.
class SquarePegAdapter extends RoundPeg is
    // In reality, the adapter contains an instance of the
    // SquarePeg class.
    private field peg: SquarePeg
    constructor SquarePegAdapter(peg: SquarePeg) is
        this.peg = peg
        
    method getRadius() is
        // radius that could fit the square peg that the adapter
        // The adapter pretends that it's a round peg with a
        // actually wraps.
        return peg.getWidth() * Math.sqrt(2) / 2
// Somewhere in client code.
hole = new RoundHole(5)
rpeg = new RoundPeg(5)
hole.fits(rpeg) // true
small_sqpeg = new SquarePeg(5)
large_sqpeg = new SquarePeg(10)
hole.fits(small_sqpeg) // this won't compile (incompatible types)
small_sqpeg_adapter = new SquarePegAdapter(small_sqpeg)
large_sqpeg_adapter = new SquarePegAdapter(large_sqpeg)
hole.fits(small_sqpeg_adapter) // true
hole.fits(large_sqpeg_adapter) // false
```

## 💡 قابلیت کاربرد
- وقتی می خواهید از کلاس های موجود استفاده کنید،اما اینترفیس آن با بقیه کد شما سازگار نیست از پترن Adapter استفاده کنید.

- ✨الگوی Adapter به شما امکان می دهد یک کلاس  میانی ایجاد کنید که به عنوان مبدل  بین کد شما و یک کلاس قدیمی، یک کلاس خارجی  یا هر کلاس دیگری با اینترفیس کاربری عجیب و غریب عمل می کند.

- هنگامی که می خواهید چندین زیر کلاس موجود را که فاقد برخی عملکردهای مشترک هستند که نمی توان به سوپرکلاس اضافه کرد، مجدداً استفاده کنید، از الگو استفاده کنید.

- ✨می‌توانید هر زیر کلاس را گسترش دهید و قابلیت‌های گمشده را در کلاس‌های فرزند جدید قرار دهید. با این حال، باید کد را در تمام این کلاس‌های جدید کپی کنید، که حرکت بسیار بدی است.
راه حل بسیار زیباتر قرار دادن قابلیت های از دست رفته در یک کلاس آداپتور است. سپس آبجکت ها با ویژگی های از دست رفته را در داخل آداپتور قرار می دهید و ویژگی های مورد نیاز را به صورت پویا به دست می آورید. برای این کار، کلاس های هدف باید یک اینترفیس کلاینت داشته باشند و فیلد آداپتور باید از آن اینترفیس پیروی کند. این رویکرد بسیار شبیه به الگوی دکوراتور است.
## ⚖️ سود ها و ضرر ها 
✔️ اصل**single responsibilty**. می توانید اینترفیس یا کد تبدیل داده را از منطق  اصلی برنامه جدا کنید.
✔️ اصل باز/بسته. شما می توانید انواع جدیدی از آداپتورها را بدون شکستن کد کلاینت  موجود به برنامه معرفی کنید، به شرطی که از طریق اینترفیس کلاینت  با آداپتورها کار کنند.
✖️ پیچیدگی کلی کد افزایش می یابد زیرا باید مجموعه ای از اینترفیس ها و کلاس های جدید را معرفی کنید. گاهی اوقات ساده تر است که کلاس سرویس را طوری تغییر دهید که با بقیه کد شما مطابقت داشته باشد.
## 📋 چگونه اداپتور بساریم ؟ 
 1. مطمئن شوید که مدل اصلی برنامه شما می تواند به عنوان یک ساختار درختی نمایش داده شود
 - یک کلاس سرویس که نمیتوان ان را تغییر داد 
 - یک یا چند کلاس کلاینت که با استفاده از کلاس سرویس سود میرسانند 
 2. یک اینترفیس کلاینت اینجاد کنید و توضیح دهید چگونه کلاینت با سرویس در ارتباط است 
 3. یک کلاس آداپتور بسازید و  موجب پیروی از کلاینت اینترفیس کنید و تمام توابع داخل ان را خالی رها کنید 
 
 4. یک فیلد را به کلاس اداپتور اضافه کنید که بتواند که ابجکت مربوط به سرویس را ذخیره کند 
 یکی از بهترین کارها این است که فیلد را مقداردهی به واسطه سازنده (constructor ) کنیم اما بعضی اوقات خیلی بهتر است که به آداپتور ارسال کنیم هنگامی که ان توابع ان را صدا میزنیم.
 
 5. یکی پس از دیگری تمام توابع اینترفیس کلاینت را داخل کلاس کلاینت پیاده سازی کنیم آداپتور باید 
 آداپتور باید بیشتر کار واقعی را به شیء سرویس واگذار 
 کند و فقط اینترفیس یا مبدل  فرمت داده را مدیریت کند.
6. کلاینت باید از اداپتور به واسطه کلاس اینترفیس اداپتور از ان استفاده کند 
او به شما این امکان را می دهد که آداپتورها را بدون تأثیر بر روی کد کلاینت  تغییر دهید یا گسترش دهید.
## 🔄 ارتباط با بقیه الگو ها
- لگوی پل معمولاً از قبل طراحی می شود و به شما امکان می دهد بخش هایی از یک برنامه را مستقل از یکدیگر توسعه دهید. از سوی دیگر، `Adapter` معمولاً با یک برنامه موجود استفاده می شود تا برخی از کلاس های ناسازگار را به خوبی با هم کار کنند.
- آداپتور اینترفیس یک شی موجود را تغییر می دهد، در حالی که `Decorator` یک شی را بدون تغییر اینترفیس آن بهبود می بخشد. علاوه بر این، `Decorator` از ترکیب بازگشتی پشتیبانی می کند، که با استفاده از آداپتور امکان پذیر نیست.
- آداپتور یک اینترفیس متفاوت برای شی    `wrrap`  شده ارائه می دهد، `Decorator` با همان اینترفیس و `Decorator` یک اینترفیس پیشرفته برای آن ارائه می دهد.
- 
فیسادها )(facade ) یک اینترفیس جدید برای اشیاء موجود تعریف -می کند، در حالی که `Decorator` سعی می کند اینترفیس موجود را قابل استفاده کند. آداپتور معمولاً فقط یک شی را می پیچد، در حالی که `Facade` با یک زیر سیستم کامل از اشیا کار می کند.
پل، `state`  استراتژی (و تا حدی آداپتور) ساختارهای بسیار مشابهی دارند. در واقع، همه این الگوها بر اساس ترکیب بندی هستند که کار را به اشیاء دیگر واگذار می کند. با این حال، همه آنها مشکلات مختلفی را حل می کنند. یک الگو فقط دستور العملی برای ساختار کد شما به روشی خاص نیست. همچنین می‌تواند مشکلی را که الگو حل می‌کند با توسعه‌دهندگان دیگر ارتباط برقرار کند 
